;
; flat16_long_trampoline.nasm: demo trampoline code for long mode in upxbc --flat16
; by pts@fazekas.hu at Wed Dec 27 04:14:44 CET 2017
;
; $ nasm -f bin -o flat16_long_trampoline.bin flat16_long_trampoline.nasm && ndisasm -b 16 flat16_long_trampoline.bin >flat16_long_trampoline.disasm
;
; This code is not used by upxbc. The portions used have been copied
; over manually from *.disasm .
;

bits 16

org 0x4000  ; Arbitrary, this is position-independent code below.

; http://www.tavi.co.uk/phobos/exeformat.html

before:  ; 0x40 bytes. Must be aligned to 16.
times 12 nop
.signature_code:
; The values we push here will be popped and used by `after:'.
.saved_ss:  ; dw ...
pushf    ; saved_return_flags
push cs  ; saved_return_cs
push cs  ; saved_return_ip, value will be overwritten at before.fix_return_ip
.saved_sp:  ; dw ...
pusha    ; saved_all_regs
push es  ; saved_es
push ds  ; saved_ds
;;;
call .me
.me:
pop ax
; Now ax contains the address (offset) of before.me, relative to cs.
add ax, after.usercode - before.me
; Now ax contains the address (offset) of after.usercode, relative to cs.
mov bp, sp
; Stack layout (from top down):
; * saved_ds at [bp]
; * saved_es at [bp+2]
; * saved_all_regs at [bp+4] ... [bp+18]
; * saved_return_ip at [bp+20]
; * saved_return_cs at [bp+22]
; * saved_return_flags at [bp+24]
.fix_return_ip:
mov [bp + 20], ax  ; ss: is the default for [bp...].
mov bx, cs
; This requires (after.usercode - after) < 16. We check it below.
shr ax, 4
add bx, ax
; Now bx contains the segment of after, with 0 offset.
lea ax, [bx - (0x100 >> 4)]
; Now ax contains the segment of (after - 0x100), i.e. the DOS PSP segment,
; with 0 offset.
mov ds, ax
mov es, ax
; This is self-modifying code: it overwrites the `push cs' above.
mov [before.saved_ss - (after - 0x100)], ss
mov [before.saved_sp - (after - 0x100)], sp
add ax, 0x1234  ; Replace constant with 0x10 + h['ss'] generated by UPX.
mov ss, ax
mov sp, 0x200  ; Replace constant with h['sp'] generated by UPX. Usually 0x200.
push bx  ; Segment to jump to below, still contains the segment of after.
push word 0  ; Offset to jump to.
retf

times 0x40-($-before) db 0x90

after:  ; <16 bytes, will be compressed. Must be aligned to 16.
mov ax, [before.saved_ss - (after - 0x100)]  ; saved_ss.
mov ss, ax
mov sp, [before.saved_sp - (after - 0x100)]  ; saved_sp.
pop ds
pop es
popa
iret  ; pop saved_return_ip ++ pop saved_return_cs ++ pop saved_return_flags
; The target of the retf above is the jump directly after the retf, i.e.
; usercode, with the segment + offset combination desired by the user.

.usercode:
; This fails to compile unless: (after.usercode - after) < 16
times 0x10-1-($-after) nop
nop

; db 'ABCDEFGHIJKLMNOPQRSTUVWXYZ_/[]'
; assert: after.usercode - before.signature_code == 0x40

mov ax, ds
add ax, 0x10
push ax
push word 0
retf


%if 0

signature:
times 12 aas
;jmp short .end  ; db 0xeb, '>'
; Sixteen-Bit-Aligned-Relocatable-Executable-Register-Preserving
db 0xeb, '>SBARERP_COMPRESSION_WILL_BE_APPLIED_AFTER_SLASH__/'
times 0x40-($-signature) nop
times 3 cwd

short_signature:
; Sixteen-Bit-Aligned-Fixed-Executable-Upx-Ucl
db 0xeb, '"SBAFEUU_COMPRESSION_AFTER_SLASH__/'
times 0x24-($-short_signature) nop

%endif
